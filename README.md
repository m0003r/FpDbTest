Текст оригинального тестового задания: [README.txt](README.txt)

# Принятые допущения
- Экранирование работает через `mysqli::real_escape_string` (иначе зачем вообще там mysqli передаётся в запросопостроитель)
- `skip()` не разрешён как элемент массива (для `?a` и  `?#`), выбрасывается исключение
- `skip()` разрешён как единственное значение (`?#`) — кажется, никто в здравом уме так пользоваться этим не будет
- В остальном `?#` позволяет только строки
- Экранирование полей работает через `
- Касты в int и float не вызывают дополнительных проверок, т.е. туда можно передать всё что угодно 
- `skip()` между двумя экземплярами не взаимозаменяем. Если это существенно, можно сделать его `static` 

# Особенности реализации

В тесте лежат две разные реализации: более простая, с использованием `preg_split`, и более выпендрёжная, в которой на PHP реализован несложный конечный автомат. В основе они одинаковы: бьют строку на части по спец. символам, и собирают на выходе массив из готовых частей, которые объединяются с помощью `implode`.

При этом по результатам измерений оказалось, что реализация на регулярках работает _быстрее_, чем вручную выписанный (и, вроде бы, более оптимальный) конечный автомат. Вероятно, причина этого в том, что внутренняя работа со строками в PCRE быстрее, чем работа со строками в PHP.  Впрочем, это не точно. JIT не особо помогает, хотя разницу в производительности уменьшает.

# Запуск тестов

Для удобства тестирования всё запаковано в docker-compose (поскольку для тестов требуется живая БД; выбрана MariaDB 11). Запускать тесты так:

```bash
docker compose run tests
# остановить БД
docker compose down
```

При этом запускаются:
- оригинальные тесты для двух реализаций
- значительно больше тестов на PHPUnit для обеих реализаций
- мутационное тестирование через Infection
- сравнение скорости через phpBench (jit включён)

В целом всё это работает достаточно быстро (порядка 1-2 µs на запрос), поэтому более простая для чтения реализация через регулярки предпочтительнее.